/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare namespace accumulator {
  export class AccumulatorAsyncServer {
    constructor(acc_fn: (datumIterator: DatumIterator) => () => Promise<Message | null>)
    stop(): void
    start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
  }
  export class DatumIterator {
    /**
     * Returns the next datum from the stream, or None if the stream has ended
     * # SAFETY
     *
     * Async function with &mut self is unsafe in napi because the self is also owned
     * by the Node.js runtime. You cannot ensure that the self is only owned by Rust.
     */
    next(): Promise<DatumIteratorResult>
  }
  export interface Datum {
    keys: Array<string>
    value: Array<number>
    watermark: Date
    eventTime: Date
    headers: Record<string, string>
    id: string
  }
  export interface DatumIteratorResult {
    value?: Datum
    done: boolean
  }
  /** Create a Message from a Datum, preserving all metadata. */
  export function fromDatum(datum: Datum, value?: Array<number> | undefined | null, keys?: Array<string> | undefined | null, tags?: Array<string> | undefined | null): Message
  /** A message to be sent to the next vertex from an accumulator handler. */
  export interface Message {
    /**
     * Keys are a collection of strings which will be passed on to the next vertex as is. It can
     * be an empty collection.
     */
    keys?: Array<string>
    /** Value is the value passed to the next vertex. */
    value: Array<number>
    /** Tags are used for [conditional forwarding](https://numaflow.numaproj.io/user-guide/reference/conditional-forwarding/). */
    tags?: Array<string>
    /** ID is used for deduplication. Read-only, set from the input datum. */
    id: string
    /** Headers for the message. Read-only, set from the input datum. */
    headers: Record<string, string>
    /** Time of the element as seen at source or aligned after a reduce operation. Read-only, set from the input datum. */
    eventTime: Date
    /** Watermark represented by time is a guarantee that we will not see an element older than this time. Read-only, set from the input datum. */
    watermark: Date
  }
  /** Drop a Message, do not forward to the next vertex. */
  export function messageToDrop(): Message
}

export declare namespace batchmap {
  export class BatchDatumIterator {
    /**
     * Returns the next datum from the stream, or None if the stream has ended
     * # SAFETY
     *
     * Async function with &mut self is unsafe in napi because the self is also owned
     * by the Node.js runtime. You cannot ensure that the self is only owned by Rust.
     */
    next(): Promise<BatchDatumIteratorResult>
  }
  export class BatchMapAsyncServer {
    constructor(batchmapFn: ((arg: BatchDatumIterator) => Promise<Array<BatchResponse>>))
    start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
    stop(): void
  }
  export class BatchMessage {
    /**
     * Keys are a collection of strings which will be passed on to the next vertex as is. It can
     * be an empty collection.
     */
    keys?: Array<string>
    /** Value is the value passed to the next vertex. */
    value: Array<number>
    /** Tags are used for [conditional forwarding](https://numaflow.numaproj.io/user-guide/reference/conditional-forwarding/). */
    tags?: Array<string>
    constructor(value: Buffer)
    withKeys(keys: Array<string>): BatchMessage
    withTags(tags: Array<string>): BatchMessage
  }
  export class BatchResponse {
    constructor(id: string)
    static fromId(id: string): BatchResponse
    append(message: BatchMessage): void
  }
  /** A collection of BatchResponse objects for a batch. */
  export class BatchResponses {
    constructor()
    /** Append a BatchResponse to the collection. */
    append(response: BatchResponse): void
  }
  export interface BatchDatum {
    /** Set of keys in the (key, value) terminology of map/reduce paradigm. */
    keys: Array<string>
    /** The value in the (key, value) terminology of map/reduce paradigm. */
    value: Buffer
    /**
     * [watermark](https://numaflow.numaproj.io/core-concepts/watermarks/) represented by time is a
     * guarantee that we will not see an element older than this time.
     */
    watermark: Date
    /** Time of the element as seen at source or aligned after a reduce operation. */
    eventtime: Date
    /** ID is the unique id of the message */
    id: string
    /** Headers for the message. */
    headers: Record<string, string>
  }
  export interface BatchDatumIteratorResult {
    value?: BatchDatum
    done: boolean
  }
  export function messageToDrop(): BatchMessage
}

export declare namespace map {
  export class MapAsyncServer {
    constructor(mapFn: ((arg: Datum) => Promise<Array<Message>>))
    start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
    stop(): void
  }
  export interface Datum {
    /** Set of keys in the (key, value) terminology of map/reduce paradigm. */
    keys: Array<string>
    /** The value in the (key, value) terminology of map/reduce paradigm. */
    value: Buffer
    /**
     * [watermark](https://numaflow.numaproj.io/core-concepts/watermarks/) represented by time is a
     * guarantee that we will not see an element older than this time.
     */
    watermark: Date
    /** Time of the element as seen at source or aligned after a reduce operation. */
    eventtime: Date
    /** Headers for the message. */
    headers: Record<string, string>
    /** User metadata for the message. */
    userMetadata: UserMetadata
    /** System metadata for the message. */
    systemMetadata: SystemMetadata
  }
  export interface Message {
    /**
     * Keys are a collection of strings which will be passed on to the next vertex as is. It can
     * be an empty collection.
     */
    keys?: Array<string>
    /** Value is the value passed to the next vertex. */
    value: Buffer
    /** Tags are used for [conditional forwarding](https://numaflow.numaproj.io/user-guide/reference/conditional-forwarding/). */
    tags?: Array<string>
    /** Watermark is the watermark passed to the next vertex. */
    userMetadata?: UserMetadata
  }
  export function messageToDrop(): Message
  export interface SystemMetadata {
    data: Record<string, Record<string, Array<number>>>
  }
  export interface UserMetadata {
    data: Record<string, Record<string, Array<number>>>
  }
}

export declare namespace mapstream {
  export class MapStreamAsyncServer {
    constructor(map_fn: (datum: Datum) => () => Promise<Message | null>)
    stop(): void
    start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
  }
  export interface Datum {
    /** Set of keys in the (key, value) terminology of the map/reduce paradigm. */
    keys: Array<string>
    /** The value in the (key, value) terminology of the map/reduce paradigm. */
    value: Buffer
    /**
     * [Watermark](https://numaflow.numaproj.io/core-concepts/watermarks/) represented by time is a
     * guarantee that we will not see an element older than this time.
     */
    watermark: Date
    /** Time of the element as seen at source or aligned after a reduce operation. */
    eventtime: Date
    /** Headers associated with the message. */
    headers: Record<string, string>
  }
  export interface Message {
    /**
     * Keys are a collection of strings which will be passed on to the next vertex as is. It can
     * be an empty collection.
     */
    keys?: Array<string>
    /** Value is the value passed to the next vertex. */
    value: Buffer
    /** Tags are used for [conditional forwarding](https://numaflow.numaproj.io/user-guide/reference/conditional-forwarding/). */
    tags?: Array<string>
  }
  export function messageToDrop(): Message
}

export declare namespace sink {
  export class KeyValueGroup {
    static new(keyValue?: Record<string, Buffer> | undefined | null): KeyValueGroup
  }
  /**
   * SinkAsyncServer is a wrapper around a JavaScript callable that will be passed by the user to process the
   * data received by the Sink.
   */
  export class SinkAsyncServer {
    /** Create a new SinkAsyncServer with the given callback. */
    constructor(sinkFn: ((arg: SinkDatumIterator) => Promise<Array<SinkResponse>>))
    /** Start the SinkAsyncServer with the given callback */
    start(socketPath?: string | undefined | null, serverInfoPath?: string | undefined | null): Promise<void>
    /** Stop the sink server */
    stop(): void
  }
  export class SinkDatumIterator {
    /**
     * Returns the next datum from the stream, or None if the stream has ended
     * # SAFETY
     *
     * Async function with &mut self is unsafe in napi because the self is also owned
     * by the Node.js runtime. You cannot ensure that the self is only owned by Rust.
     */
    next(): Promise<SinkDatumIteratorResult>
  }
  export class SinkMessage {
    /**
     * Create a new Message with the given value.
     * Keys and user_metadata are optional.
     */
    constructor(value: Buffer)
    withKeys(keys: Array<string>): SinkMessage
    /** Accept KeyValueGroup as a reference [ref](https://github.com/napi-rs/napi-rs/blob/main/crates/napi/src/bindgen_runtime/js_values/class.rs#L60) */
    withUserMetadata(metadata: Record<string, KeyValueGroup>): SinkMessage
    build(): SinkMessage | null
  }
  export class SinkResponse {
    static failure(id: string, err: string): SinkResponse
    static ok(id: string): SinkResponse
    static fallback(id: string): SinkResponse
    static serve(id: string, payload: Array<number>): SinkResponse
    static onSuccess(id: string, payload?: SinkMessage | undefined | null): SinkResponse
  }
  export class SinkResponses {
    static new(): SinkResponses
    push(response: SinkResponse): void
    pushAll(responses: Array<SinkResponse>): void
    len(): number
    isEmpty(): boolean
  }
  export interface SinkDatum {
    /** Set of keys in the (key, value) terminology of map/reduce paradigm. */
    keys: Array<string>
    /** The value in the (key, value) terminology of map/reduce paradigm. */
    value: Buffer
    /** Watermark represented by time (Unix timestamp in milliseconds). */
    watermark: Date
    /** Event time (Unix timestamp in milliseconds). */
    eventtime: Date
    /** ID is the unique id of the message to be sent to the Sink. */
    id: string
    /** Headers for the message. */
    headers: Record<string, string>
    userMetadata: UserMetadata
    systemMetadata: SystemMetadata
  }
  export interface SinkDatumIteratorResult {
    value?: SinkDatum
    done: boolean
  }
  export interface SystemMetadata {
    data: Record<string, Record<string, Array<number>>>
  }
  export interface UserMetadata {
    data: Record<string, Record<string, Array<number>>>
  }
}

export declare namespace sourceTransform {
  export class SourceTransformAsyncServer {
    constructor(sourceTransformFn: ((arg: SourceTransformDatum) => Promise<Array<SourceTransformMessage>>))
    start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
    stop(): void
  }
  export function messageToDrop(eventtime: Date): SourceTransformMessage
  export interface SourceTransformDatum {
    /** Set of keys in the (key, value) terminology of map/reduce paradigm. */
    keys: Array<string>
    /** The value in the (key, value) terminology of map/reduce paradigm. */
    value: Buffer
    /**
     * [watermark](https://numaflow.numaproj.io/core-concepts/watermarks/) represented by time is a
     * guarantee that we will not see an element older than this time.
     */
    watermark: Date
    /** Time of the element as seen at source or aligned after a reduce operation. */
    eventtime: Date
    /** Headers for the message. */
    headers: Record<string, string>
    /** User metadata for the message. */
    userMetadata: UserMetadata
    /** System metadata for the message. */
    systemMetadata: SystemMetadata
  }
  export interface SourceTransformMessage {
    /**
     * Keys are a collection of strings which will be passed on to the next vertex as is. It can
     * be an empty collection.
     */
    keys?: Array<string>
    /** Value is the value passed to the next vertex. */
    value: Buffer
    /**
     * Time for the given event. This will be used for tracking watermarks. If cannot be derived, set it to the incoming
     * event_time from the [`SourceTransformRequest`].
     */
    eventtime: Date
    /** Tags are used for [conditional forwarding](https://numaflow.numaproj.io/user-guide/reference/conditional-forwarding/). */
    tags?: Array<string>
    /** User metadata for the message. */
    userMetadata?: UserMetadata
  }
  export interface SystemMetadata {
    data: Record<string, Record<string, Array<number>>>
  }
  export interface UserMetadata {
    data: Record<string, Record<string, Array<number>>>
  }
}
