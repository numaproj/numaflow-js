/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare namespace accumulator {
    export class AccumulatorAsyncServer {
        constructor(acc_fn: (datumIterator: DatumIterator) => () => Promise<Message | null>)
        stop(): void
        start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
    }
    export class DatumIterator {
        /**
         * Returns the next datum from the stream, or None if the stream has ended
         * # SAFETY
         *
         * Async function with &mut self is unsafe in napi because the self is also owned
         * by the Node.js runtime. You cannot ensure that the self is only owned by Rust.
         */
        next(): Promise<DatumIteratorResult>
    }
    export interface Datum {
        keys: Array<string>
        value: Array<number>
        watermark: Date
        eventTime: Date
        headers: Record<string, string>
        id: string
    }
    export interface DatumIteratorResult {
        value?: Datum
        done: boolean
    }
    /** Create a Message from a Datum, preserving all metadata. */
    export function fromDatum(
        datum: Datum,
        value?: Array<number> | undefined | null,
        keys?: Array<string> | undefined | null,
        tags?: Array<string> | undefined | null,
    ): Message
    /** A message to be sent to the next vertex from an accumulator handler. */
    export interface Message {
        /**
         * Keys are a collection of strings which will be passed on to the next vertex as is. It can
         * be an empty collection.
         */
        keys?: Array<string>
        /** Value is the value passed to the next vertex. */
        value: Array<number>
        /** Tags are used for [conditional forwarding](https://numaflow.numaproj.io/user-guide/reference/conditional-forwarding/). */
        tags?: Array<string>
        /** ID is used for deduplication. Read-only, set from the input datum. */
        id: string
        /** Headers for the message. Read-only, set from the input datum. */
        headers: Record<string, string>
        /** Time of the element as seen at source or aligned after a reduce operation. Read-only, set from the input datum. */
        eventTime: Date
        /** Watermark represented by time is a guarantee that we will not see an element older than this time. Read-only, set from the input datum. */
        watermark: Date
    }
    /** Drop a Message, do not forward to the next vertex. */
    export function messageToDrop(): Message
}

export declare namespace batchmap {
    export class BatchDatumIterator {
        /**
         * Returns the next datum from the stream, or None if the stream has ended
         * # SAFETY
         *
         * Async function with &mut self is unsafe in napi because the self is also owned
         * by the Node.js runtime. You cannot ensure that the self is only owned by Rust.
         */
        next(): Promise<BatchDatumIteratorResult>
    }
    export class BatchMapAsyncServer {
        constructor(batchmapFn: (arg: BatchDatumIterator) => Promise<Array<BatchResponse>>)
        start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
        stop(): void
    }
    export class BatchMessage {
        /**
         * Keys are a collection of strings which will be passed on to the next vertex as is. It can
         * be an empty collection.
         */
        keys?: Array<string>
        /** Value is the value passed to the next vertex. */
        value: Array<number>
        /** Tags are used for [conditional forwarding](https://numaflow.numaproj.io/user-guide/reference/conditional-forwarding/). */
        tags?: Array<string>
        constructor(value: Buffer)
        withKeys(keys: Array<string>): BatchMessage
        withTags(tags: Array<string>): BatchMessage
    }
    export class BatchResponse {
        constructor(id: string)
        static fromId(id: string): BatchResponse
        append(message: BatchMessage): void
    }
    /** A collection of BatchResponse objects for a batch. */
    export class BatchResponses {
        constructor()
        /** Append a BatchResponse to the collection. */
        append(response: BatchResponse): void
    }
    export interface BatchDatum {
        /** Set of keys in the (key, value) terminology of map/reduce paradigm. */
        keys: Array<string>
        /** The value in the (key, value) terminology of map/reduce paradigm. */
        value: Buffer
        /**
         * [watermark](https://numaflow.numaproj.io/core-concepts/watermarks/) represented by time is a
         * guarantee that we will not see an element older than this time.
         */
        watermark: Date
        /** Time of the element as seen at source or aligned after a reduce operation. */
        eventTime: Date
        /** ID is the unique id of the message */
        id: string
        /** Headers for the message. */
        headers: Record<string, string>
    }
    export interface BatchDatumIteratorResult {
        value?: BatchDatum
        done: boolean
    }
    export function messageToDrop(): BatchMessage
}

export declare namespace map {
    export class Datum {
        /** Set of keys in the (key, value) terminology of map/reduce paradigm. */
        keys: Array<string>
        constructor(
            keys: Array<string>,
            value: Array<number>,
            watermark: Date,
            eventTime: Date,
            headers: Record<string, string>,
            userMetadata?: UserMetadata | undefined | null,
            systemMetadata?: SystemMetadata | undefined | null,
        )
        get value(): Buffer
        get watermark(): Date
        get eventTime(): Date
        get headers(): Record<string, string>
        get userMetadata(): UserMetadata | null
        get systemMetadata(): SystemMetadata | null
        set userMetadata(userMetadata: UserMetadata)
    }
    export class MapAsyncServer {
        constructor(mapFn: (arg: Datum) => Promise<Array<Message>>)
        start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
        stop(): void
    }
    export class SystemMetadata {
        constructor()
        getGroups(): Array<string>
        getKeys(group: string): Array<string>
        getValue(group: string, key: string): Buffer
    }
    export class UserMetadata {
        constructor()
        getGroups(): Array<string>
        getKeys(group: string): Array<string>
        getValue(group: string, key: string): Buffer
        createGroup(group: string): void
        addKv(group: string, key: string, value: Buffer): void
        removeKey(group: string, key: string): void
        removeGroup(group: string): void
    }
    export interface Message {
        /**
         * Keys are a collection of strings which will be passed on to the next vertex as is. It can
         * be an empty collection.
         */
        keys?: Array<string>
        /** Value is the value passed to the next vertex. */
        value: Buffer
        /** Tags are used for [conditional forwarding](https://numaflow.numaproj.io/user-guide/reference/conditional-forwarding/). */
        tags?: Array<string>
        /** User metadata for the message. */
        userMetadata?: Record<string, Record<string, Buffer>>
    }
}

export declare namespace mapstream {
    export class MapStreamAsyncServer {
        constructor(map_fn: (datum: Datum) => () => Promise<Message | null>)
        stop(): void
        start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
    }
    export interface Datum {
        /** Set of keys in the (key, value) terminology of the map/reduce paradigm. */
        keys: Array<string>
        /** The value in the (key, value) terminology of the map/reduce paradigm. */
        value: Buffer
        /**
         * [Watermark](https://numaflow.numaproj.io/core-concepts/watermarks/) represented by time is a
         * guarantee that we will not see an element older than this time.
         */
        watermark: Date
        /** Time of the element as seen at source or aligned after a reduce operation. */
        eventTime: Date
        /** Headers associated with the message. */
        headers: Record<string, string>
    }
    export interface Message {
        /**
         * Keys are a collection of strings which will be passed on to the next vertex as is. It can
         * be an empty collection.
         */
        keys?: Array<string>
        /** Value is the value passed to the next vertex. */
        value: Buffer
        /** Tags are used for [conditional forwarding](https://numaflow.numaproj.io/user-guide/reference/conditional-forwarding/). */
        tags?: Array<string>
    }
    export function messageToDrop(): Message
}

export declare namespace reduce {
    export class ReduceAsyncServer {
        /** Create a new ReduceAsyncServer with the given callback. */
        constructor(reduceFn: (iterator: ReduceCallbackArgs) => Promise<Array<Message>>)
        /** Start the ReduceAsyncServer with the given callback */
        start(socketPath?: string | undefined | null, serverInfoPath?: string | undefined | null): Promise<void>
        /** Stop the reduce server */
        stop(): void
    }
    /**
     * Arguments passed to the reduce callback
     * Only to be used as part of internal implementation, not to be exposed to final users
     */
    export class ReduceCallbackArgs {
        get keys(): Array<string>
        get takeIterator(): ReduceDatumIterator
        get metadata(): Metadata
    }
    export class ReduceDatumIterator {
        /** Returns the next datum from the stream, or None if the stream has ended */
        next(): Promise<ReduceDatumIteratorResult>
    }
    export interface Datum {
        keys: Array<string>
        value: Buffer
        watermark: Date
        eventTime: Date
        headers: Record<string, string>
    }
    export interface IntervalWindow {
        start: Date
        end: Date
    }
    export interface Message {
        /** optional keys */
        keys?: Array<string>
        /** payload */
        value: Buffer
        /** optional tags */
        tags?: Array<string>
    }
    /** Drop a Message, do not forward to the next vertex. */
    export function messageToDrop(): Message
    /** Metadata passed to reducer handler */
    export interface Metadata {
        intervalWindow: IntervalWindow
    }
    export interface ReduceDatumIteratorResult {
        value?: Datum
        done: boolean
    }
}

export declare namespace reduceStream {
    export class ReduceStreamAsyncServer {
        /** Create a new ReduceStreamAsyncServer with the given callback. */
        constructor(reduceStreamFn: (iterator: ReduceCallbackArgs) => () => Promise<Message | null>)
        /** Start the ReduceStreamAsyncServer with the given callback */
        start(socketPath?: string | undefined | null, serverInfoPath?: string | undefined | null): Promise<void>
        /** Stop the reduce stream server */
        stop(): void
    }
}

export declare namespace sessionReduce {
    export class SessionReduceAsyncServer {
        /** Create a new SessionReduceAsyncServer with the given callback. */
        constructor(
            session_reduce_fn: (args: SessionReduceCallbackArgs) => () => Promise<Message | null>,
            accumulator_fn: () => Promise<Buffer>,
            merge_accumulator_fn: (accumulator: Buffer) => Promise<void>,
        )
        stop(): void
        start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
    }
    /**
     * Arguments passed to the reduce callback
     * Only to be used as part of internal implementation, not to be exposed to final users
     */
    export class SessionReduceCallbackArgs {
        get keys(): Array<string>
        get takeIterator(): SessionReduceDatumIterator
    }
    export class SessionReduceDatumIterator {
        /**
         * Returns the next datum from the stream, or None if the stream has ended
         * # SAFETY
         *
         * Async function with &mut self is unsafe in napi because the self is also owned
         * by the Node.js runtime. You cannot ensure that the self is only owned by Rust.
         */
        next(): Promise<SessionReduceDatumIteratorResult>
    }
    export interface Datum {
        keys: Array<string>
        value: Array<number>
        watermark: Date
        eventTime: Date
        headers: Record<string, string>
    }
    export interface Message {
        /** optional keys */
        keys?: Array<string>
        /** payload */
        value: Buffer
        /** optional tags (e.g., DROP) */
        tags?: Array<string>
    }
    /** Drop a Message, do not forward to the next vertex. */
    export function messageToDrop(): Message
    export interface SessionReduceDatumIteratorResult {
        value?: Datum
        done: boolean
    }
}

export declare namespace sideInput {
    export class SideInputAsyncServer {
        constructor(sideInputFn: () => Promise<Buffer | null>)
        start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
        stop(): void
    }
}

export declare namespace sink {
    /**
     * SinkAsyncServer is a wrapper around a JavaScript callable that will be passed by the user to process the
     * data received by the Sink.
     */
    export class SinkAsyncServer {
        /** Create a new SinkAsyncServer with the given callback. */
        constructor(sinkFn: (arg: SinkDatumIterator) => Promise<Array<SinkResponse>>)
        /** Start the SinkAsyncServer with the given callback */
        start(socketPath?: string | undefined | null, serverInfoPath?: string | undefined | null): Promise<void>
        /** Stop the sink server */
        stop(): void
    }
    export class SinkDatum {
        /** Set of keys in the (key, value) terminology of map/reduce paradigm. */
        keys: Array<string>
        /** ID is the unique id of the message to be sent to the Sink. */
        id: string
        getValue(): Buffer
        getWatermark(): Date
        getEventtime(): Date
        getHeaders(): Record<string, string>
        userMetadata(): SinkUserMetadata
        systemMetadata(): SinkSystemMetadata
    }
    export class SinkDatumIterator {
        /**
         * Returns the next datum from the stream, or None if the stream has ended
         * # SAFETY
         *
         * Async function with &mut self is unsafe in napi because the self is also owned
         * by the Node.js runtime. You cannot ensure that the self is only owned by Rust.
         */
        next(): Promise<SinkDatum | null>
    }
    export class SinkMessage {
        /**
         * Create a new Message with the given value.
         * Keys and user_metadata are optional.
         */
        constructor(value: Buffer, keys?: Array<string> | undefined | null)
    }
    export class SinkResponse {
        static failure(id: string, err: string): SinkResponse
        static ok(id: string): SinkResponse
        static fallback(id: string): SinkResponse
        static serve(id: string, payload: Array<number>): SinkResponse
        static onSuccess(id: string, payload?: SinkMessage | undefined | null): SinkResponse
    }
    export class SinkResponses {
        static new(): SinkResponses
        push(response: SinkResponse): void
        pushAll(responses: Array<SinkResponse>): void
        len(): number
        isEmpty(): boolean
    }
    export class SinkSystemMetadata {
        constructor()
        getGroups(): Array<string>
        getKeys(group: string): Array<string>
        getValue(group: string, key: string): Buffer
    }
    export class SinkUserMetadata {
        constructor()
        getGroups(): Array<string>
        getKeys(group: string): Array<string>
        getValue(group: string, key: string): Buffer
    }
}

export declare namespace source {
    export class ReadRequest {
        /** Get the number of records to read. */
        get numRecords(): number
        /** Get the timeout in milliseconds. */
        get timeoutMs(): number
    }
    export class SourceAsyncServer {
        constructor(
            read_fn: (request: ReadRequest) => () => Promise<Message | null>,
            ack_fn: (offsets: Offset[]) => Promise<void>,
            nack_fn: (offsets: Offset[]) => Promise<void>,
            pending_fn: () => Promise<number | null>,
            partition_fn: () => Promise<number[] | null>,
        )
        /** Start the SourceAsyncServer with the given callback */
        start(socketPath?: string | undefined | null, serverInfoPath?: string | undefined | null): Promise<void>
        /** Stop the SourceAsyncServer server */
        stop(): void
    }
    export class SourceUserMetadata {
        constructor()
        getGroups(): Array<string>
        getKeys(group: string): Array<string>
        getValue(group: string, key: string): Buffer
        createGroup(group: string): void
        addKv(group: string, key: string, value: Buffer): void
        removeKey(group: string, key: string): void
        removeGroup(group: string): void
    }
    export interface Message {
        /** The payload of the message. */
        payload: Buffer
        /** The offset of the message */
        offset: Offset
        /** The event time of the message. */
        eventTime: Date
        /** Keys of the message. */
        keys: Array<string>
        /** Headers of the message. */
        headers: Record<string, string>
        /** User metadata for the message. */
        userMetadata?: Record<string, Record<string, Buffer>>
    }
    export interface Offset {
        /** Offset value in bytes. */
        offset: Buffer
        /** Partition ID of the message. */
        partitionId: number
    }
}

export declare namespace sourceTransform {
    export class SourceTransformAsyncServer {
        constructor(sourceTransformFn: (arg: SourceTransformDatum) => Promise<Array<SourceTransformMessage>>)
        start(sockFile?: string | undefined | null, infoFile?: string | undefined | null): Promise<void>
        stop(): void
    }
    export class SourceTransformDatum {
        /** Set of keys in the (key, value) terminology of map/reduce paradigm. */
        keys: Array<string>
        constructor(
            keys: Array<string>,
            value: Buffer,
            watermark: Date,
            eventTime: Date,
            headers: Record<string, string>,
            userMetadata?: SourceTransformUserMetadata | undefined | null,
            systemMetadata?: SourceTransformSystemMetadata | undefined | null,
        )
        get value(): Buffer
        get watermark(): Date
        get eventTime(): Date
        get headers(): Record<string, string>
        get userMetadata(): SourceTransformUserMetadata | null
        get systemMetadata(): SourceTransformSystemMetadata | null
        set userMetadata(userMetadata: SourceTransformUserMetadata)
    }
    export class SourceTransformSystemMetadata {
        constructor()
        getGroups(): Array<string>
        getKeys(group: string): Array<string>
        getValue(group: string, key: string): Buffer
    }
    export class SourceTransformUserMetadata {
        constructor()
        getGroups(): Array<string>
        getKeys(group: string): Array<string>
        getValue(group: string, key: string): Buffer
        createGroup(group: string): void
        addKv(group: string, key: string, value: Buffer): void
        removeKey(group: string, key: string): void
        removeGroup(group: string): void
    }
    export function messageToDrop(eventTime: Date): SourceTransformMessage
    export interface SourceTransformMessage {
        /**
         * Keys are a collection of strings which will be passed on to the next vertex as is. It can
         * be an empty collection.
         */
        keys?: Array<string>
        /** Value is the value passed to the next vertex. */
        value: Buffer
        /**
         * Time for the given event. This will be used for tracking watermarks. If cannot be derived, set it to the incoming
         * event_time from the [`SourceTransformRequest`].
         */
        eventTime: Date
        /** Tags are used for [conditional forwarding](https://numaflow.numaproj.io/user-guide/reference/conditional-forwarding/). */
        tags?: Array<string>
        /** User metadata for the message. */
        userMetadata?: Record<string, Record<string, Buffer>>
    }
}
